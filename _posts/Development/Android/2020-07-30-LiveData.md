---
layout : post
title : "라이브데이터"
subtitle : "LiveData 정리"
category : development
tags : android
---

# LiveData 정리

라이브 데이터(LiveData)는 

ViewModel 클래스의 데이터를 View에서 사용할 수 있는 기법이다.



물론 LiveDate를 사용하지 않고도

View에서 ViewModel 클래스 객체의 함수를 호출해 반환 값을 받아서 사용해도 되긴 한다. (게터 함수 같이)



그러나 LiveData의 옵서버를 사용하면 ViewModel 클래스의 데이터의 값이 변경될 때마다 콜백함수로 받을 수 있기 때문에

기능적으로 좀 더 사용하기 좋고 효율적이라고 볼 수 있다.



#### ViewModel

```java
public MutableLiveData<String> str = new MutableLiveData<String>();
public MutableLiveData<Integer> counter = new MutableLiveData<Integer>();
```

위와 같이 LiveData 변수를 생성할 수 있다.

주의할점은 접근지정자를 항상 public으로 해야한다는 것.



해당 변수에 값을 대입하는 방식은 2가지가 있다.

```java
        counter.postValue(r_counter++);
        str.postValue((r_counter * 2 - 1) +" 넘버");

        counter.setValue(r_counter++);
        str.setValue((r_counter * 2 - 1) +" 넘버");
```

바로 `postValue` , `setValue` 방식.



먼저 `postValue` 방식은 백그라운드 스레드에 의해 동작하기 때문에 메인 스레드/ 백그라운드 스레드 모두 사용이 가능하다.

그러나 `setValue`방식은 메인스레드에 의해 동작하기 때문에 메인 스레드에서만 동작하고 백그라운드 스레드에서는 Cannot invoke setValue on background Thread 라는 오류가 발생하게 된다.



대부분의 경우에는 `postValue`를 사용하면 되지만, 여기서도 한가지 주의할 점이 있다.

`postValue`는 View에서 옵서버를 사용하지 않고 직접 데이터를 받으려고 할때는 결과값을 전달할 수 없다.

이런 경우에는 `setValue`를 사용할 것 



물론, 그런 경우는 거의 없을 것이기 때문에 `postValue`를 주로 사용한다고 보면 될 것 같다.



---

#### View

뷰에서는 LiveDate가 있는 Class 객체를 생성하고 Observer를 구현하여 해당 변수 혹은 함수에 `observe` 하면 된다



```java
Observer<String> observer = new Observer<String>(){
    @Override
    public void onChanged(@Nullable String s){
        Log.d("TAG", "Value : " + s);
    }
};

viewModel.str.observe(this, observer);
```

위와 같이 Observer 객체인 observer를 생성하고 `onChanged` 함수를 오버라이딩하여 구현할 내용을 코딩한다.

그리고 viewmodel 이라는 클래스 객체 내에 있는 str 변수(혹은 함수)에 `observe`하면 자동으로 해당 변수(혹은 함수)가 변경될 때마다 observer 함수가 호출된다.

( `postValue`가 호출될 때마다 등록된 observer의 onChanged 함수가 호출되는 것)



이는 람다식으로 좀 더 쉽게 구현할 수 있다.

```java
        viewmodel.str.observe(this, result->{
				Log.d("TAG", "Value : " + result);
        });
```



observer로 만들 함수를 재사용할 필요가 없다면 람다식이 깔끔하다.

이외에 LiveData를 커스텀할 수 있는 방법도 있긴 하지만, 현재 나에겐 필요가 없으니 그런게 있다는 것만 알아 두면 될 것 같다.



---

### 끝마침

사실 `DataBinding`을 통해 XML의 UI를 실시간으로 변경해주는 것을 할 수 있었다. 거기에 `@BindingAdapter` 를 이용해 커스터마이징해서 사용할 수도 있었으니 한계는 없다고 보면 된다.

따라서, LiveData를 단순히 View 값을 변경해주는데 쓰는 건 비효율적이고 데이터가 변경될 때 수행해야되는 비즈니스 로직이 별도로 존재할 때 사용하면 될 것 같다.



둘의 차이는 명확하고 사용법도 명확하게 나뉘어져 있으니 상황에 따라 맞춰서 사용하면 되겠다. 물론 그 중에서 뭘 선택해야 더 효율적인가에 대해서는 끝없이 고민해야될 문제가 될 것 같지만...